<%--  :mode=jsp: --%>


<%--{{{ Intro --%>

<h1 style="background:url(${cdn}${jqt}/img/hero/validator.jpg) no-repeat 0 45px">
	jQuery Validator @ jQuery Tools
	<em>HTML5 input validation for humans</em>
</h1>

<p class="more" style="margin-top:5px">
	The 20 year wait is over. Enter the missing form validation tool. It takes the best parts of <strong>HTML 5</strong> and <strong>Web Forms 2.0</strong> standards and turns them into something pure amazing. All in <strong>1.75 Kb</strong> of code.
</p>

<%@ include file="../demos/validator/index.htm" %>

<div style="height:40px"></div>

<div class="feat">

	<h3 class="first">Use HTML5 input types today</h3>

	<p>
		HTML5 provides new input types such as <samp>number</samp>, <samp>email</samp> and <samp>url</samp>, and attributes such as <samp>min</samp>, <samp>max</samp>, <samp>required</samp> and <samp>pattern</samp>. These work out of the box and will add a new dimension to your everyday forms. If that's not enough it's easy to create your own custom inputs.
	</p>

</div>

<div class="feat last">

	<h3 class="first">Take control of your error messages</h3>

	<p>
		You can fully control when, where and how the error messages are shown. Below, above or beside the field. All at once or one at the time. Big or small. Different languages for different locations. When an invalid field is edited the error message will dynamically change or disappear depending on the input.
	</p>

</div>


<div class="feat">

	<h3>Server-side integration</h3>

	<p>
		You can use a generic <samp>invalidate</samp> function to display errors that occurred on the server-side. The logic is not tied to any particular server-side framework and it is easy to integrate into your existing server-side code. The only server requirement is the capability to return data in JSON format.
	</p>

</div>

<div class="feat last">

	<h3>Web Forms 2.0</h3>

	<p>
		<a href="http://www.whatwg.org/specs/web-forms/current-work/#form-validation" class="external">Web Forms 2.0</a> is a large and complex standard. This tool follows the standard and uses a sane subset of it. For example, you can use the <samp>form.checkValidity()</samp> method or you can define an <samp>oninvalid</samp> callback functions for your inputs.
	</p>

</div>

<br clear="all" />


<%--}}}--%>


<%--{{{ Usage --%>

<a name="usage"></a>
<h2>Usage</h2>

<p>
	You take any form you like, spice it up with new HTML5 input types and attributes and make a single call to jQuery Tools <samp>validator</samp>. Here is the HTML layout for the example form above:
</p>

<pii:code lang="html">
<%@ include file="../demos/validator/myform.jsf" %>
</pii:code>

<p>
	And here is the <samp>validator</samp> call that enables form validation:
</p>

<pii:code>
$("#myform").validator();
</pii:code>

<p>
	When the form is submitted the validator will make sure that the input fields pass all the rules that are defined for them. If there are any errors an error message appears above all failed fields. When the user starts fixing the values each error message will magically disappear once the input is valid. Look at the <a href="../demos/validator/index.html">minimal setup</a> for more details.
</p>

<h3>Validating inputs without a form</h3>

<p>
	The tool validates all input fields except buttons and hidden fields inside a particular form. You can also select particular fields and validate them. For example:
</p>

<pii:code>
// initialize validator for a bunch of input fields
var inputs = $("#mydiv :input").validator();

// perform validation programmatically
inputs.data("validator").checkValidity();
</pii:code>


<p>
	Since v1.2.3 another <samp>$("...").validator()</samp> call would <a href="#">destroy</a> the existing instance and will install a completely new validator instance. 
</p>


<%--}}}--%>


<a name="demos"></a>
<h2>Demos</h2>

<p>
	Please study the first demo "Minimal setup for Validator". It teaches you the basics of form validation.
</p>

<ul>
	<c:forEach items="${f:getDemo(context.toolDemos2, 'validator/index.html').category.demos}" var="demo">
		<li> <a href="../demos/${demo.path}">${demo.title}</a> </li>
	</c:forEach>
</ul>

<%--{{{ HTML --%>

<a name="html5"></a>
<h2>Supported HTML5 features</h2>

<p>
	jQuery Tools Validator adds new input types and attributes to your form construction arsenal.
</p>

<h3>HTML5 input types</h3>

<p>
	Now you can specify more than just "text", "checkbox" or "radio" for your <samp>type</samp> attribute. Here are the new types supported by validator:
</p>

<table class="listing">
	<thead>
		<tr>
			<th>type</th>
			<th>Description</th>
		</tr>
	</thead>

	<tr>
		<td class="code">email</td>
		<td>Accepts a valid email address only. For example <samp>&lt;input type="email" name="email" /&gt;</samp>.</td>
	</tr>
	<tr>
		<td class="code">number</td>
		<td>Accepts integer or floating point numbers only.</td>
	</tr>
	<tr>
		<td class="code">url</td>
		<td>Accepts a valid URL only.</td>
	</tr>

</table>

<p>
	HTML5 <samp>range</samp> and <samp>date</samp> types are also supported by using the <a href="${jqt}/rangeinput/">rangeinput</a> and <a href="${jqt}/dateinput/">dateinput</a> Tools. Empty values are allowed for all input types. If you don't want to allow empty values use the <samp>required</samp> attribute.
</p>

<p>
	For jQuery users the <samp>:email</samp>, <samp>:number</samp> and <samp>:url</samp> selectors are available for convenience.
</p>


<h3>HTML5 Attributes</h3>

<table class="listing">
	<thead>
		<tr>
			<th>Attribute</th>
			<th nowrap>Data Type</th>
			<th>Description</th>
		</tr>
	</thead>

	<tr>
		<td class="code">max</td>
		<td><code>Number</code></td>
		<td>Maximum numeric value for the field. Valid for <samp>number</samp>, <samp>text</samp>, <samp>date</samp> and <samp>range</samp> inputs.</td>
	</tr>
	<tr>
		<td class="code">min</td>
		<td><code>Number</code></td>
		<td>Minimum numeric value for the field. Valid for <samp>number</samp>, <samp>text</samp>, <samp>date</samp> and <samp>range</samp> inputs.</td>
	</tr>
	<tr>
		<td class="code">pattern</td>
		<td><code>RegExp</code></td>
		<td>Defines the required pattern or format for the input field's submitted value. Example: pattern="[0-9]" means that the input value must be a number between 0 and 9. It's recommend to use the "title" attribute to describe the pattern.</td>
	</tr>
	<tr>
		<td class="code">required</td>
		<td><code>"required"</code></td>
		<td>
			Makes value submission mandatory for this field. The standard syntax is <samp>required="required"</samp> is needed! Plain <samp>required</samp> or <samp>required="true"</samp> does not work. This attribute works also with checkbox and SELECT fields. 
		</td>
	</tr>
</table>

<h3>HTML4 Attributes</h3>

<p>
	These good old HTML4 attributes have a role in form validation and will make your forms more user friendly:
</p>

<table class="listing">
	<thead>
		<tr>
			<th>Attribute</th>
			<th nowrap>Data Type</th>
			<th>Description</th>
		</tr>
	</thead>


	<tr>
		<td class="code">disabled</td>
		<td><code></code></td>
		<td>Makes the field non-editable. The field cannot receive focus and is excluded from validation. The field appears "greyed out" in the browser. In HTML5 you should be able to disable/enable a set of inputs by enclosing them inside a <samp>fieldset</samp> element and toggling the <samp>disabled</samp> attribute of the <samp>fieldset</samp> element. However, this didn't work on Firefox 3.5 by the time of writing.</td>
	</tr>
	<tr>
		<td class="code">maxlength</td>
		<td><code>number</code></td>
		<td>Attribute to restrict the input's length to a specific value. This will forbid the user from inputting more characters than are allowed. This behaviour is inherent for the browser and is not a feature of the validator tool.</td>
	</tr>
	<tr>
		<td class="code">readonly</td>
		<td><code></code></td>
		<td>Makes the field non-editable. The field <em>can</em> receive focus and is included in the validation. As with the <samp>disabled</samp> attribute the field appears "greyed out" in the browser but in a slightly different way.</td>
	</tr>
	<tr>
		<td class="code">title</td>
		<td><code>string</code></td>
		<td>Provides advisory information about the element. You can often see this attribute being used for the wrong purpose. Some frameworks use it for validation error messages. This is wrong. Only use it to describe what kind of input the field accepts.</td>
	</tr>

</table>

<p>
	<strong>Note:</strong> all the above attributes can be changed dynamically using jQuery's <samp>attr</samp> method. For example:
</p>

<pii:code>
$("fieldset:eq(1)").attr("disabled", true);
</pii:code>

<p>
	In addition to the above HTML attributes, jQuery Tools allows you to implement your own <a href="#custom">custom attributes</a> for validation.
</p>

<%--}}}--%>


<%--{{{ Configuration --%>

<a name="configuration"></a>
<h2>Configuration</h2>

<table class="listing">
	<thead>
		<tr>
			<th>Property</th>
			<th>Default</th>
			<th>Description</th>
		</tr>
	</thead>
	<tr>
		<td class="code">effect</td>
		<td><code>'default'</code></td>
		<td>
			By default error messages are shown beside the input field. You can override this default behaviour altogether and make the error messages appear any way you like. for example, you can show all error messages inside one big container. Only the "default" effect is built-in. Look at the details of <a href="#effects">developing custom effects</a>.
		</td>
	</tr>
	<tr>
		<td class="code">errorClass</td>
		<td><code>'invalid'</code></td>
		<td>
			A CSS class name that is assigned to the input field when a validation error occurs.
		</td>
	</tr>
	<tr>
		<td class="code">errorInputEvent</td>
		<td><code>'keyup'</code></td>
		<td>
			The event that triggers the input validity check. By default this occurs on every keystroke by the user. Other valid events include <samp>change</samp>, <samp>blur</samp> or <samp>null</samp>, the latter disabling input validation for a single field.
		</td>
	</tr>
	<tr>
		<td class="code">formEvent</td>
		<td><code>'submit'</code></td>
		<td>
			The event when form validation is performed. By default this happens when the form is submitted. Setting this to <samp>null</samp> prevents this behaviour. You can experiment with other events such as <samp>click</samp> and <samp>mouseover</samp> but it might not be worth the effort.
		</td>
	</tr>
	<tr>
		<td class="code">grouped</td>
		<td><code>false</code></td>
		<td>
			When there are multiple rules specified for a field such as <samp>type="email"</samp> and <samp>required</samp> enabling this makes all error messages show up together instead of one at a time.
		</td>
	</tr>
	<tr>
		<td class="code">inputEvent</td>
		<td><code>null</code></td>
		<td>
			You can validate an input field even though it's already valid. Setting <samp>keyup</samp> here validates the field every time a character is entered. By default the input is only validated when it has an invalid value as specified in the <samp>errorInputEvent</samp> configuration variable. Valid events for this property are <samp>keyup</samp>, <samp>change</samp>, <samp>blur</samp> or <samp>null</samp>.
		</td>
	</tr>
	<tr>
		<td class="code"><a name="configuration/lang"></a>lang</td>
		<td><code>'en'</code></td>
		<td>
			The language used in the error messages. See <a href="#localization">localization</a> for details.
		</td>
	</tr>
	<tr>
		<td class="code">message</td>
		<td nowrap><code>'&lt;div/&gt;</td>
		<td>
			HTML layout for the error message. The actual errors are <samp>span</samp> elements that are <em>appended</em> to the message element. This configuration option allows you to specify as complex a layout as you wish. You can for example add a nested <samp>div</samp> element as a placeholder for an arrow.
		</td>
	</tr>
	<tr>
		<td class="code">messageAttr</td>
		<td><code>'data-message'</code></td>
		<td>
			Name of the attribute that contains an error message to be shown when a validation error occurs for this field. This value overrides all validator specific error messages and does not care about (client-side) localization. Read more about <a href="#input_message">input specific error messages</a>.
		</td>
	</tr>
	<tr>
		<td class="code">messageClass</td>
		<td><code>'error'</code></td>
		<td>
			CSS class name defined for the error message element.
		</td>
	</tr>
	<tr>
		<td class="code">offset</td>
		<td><code>[0, 0]</code></td>
		<td>
			Fine tunes the tooltip position specified with the <samp>position</samp> property. See the <a href="#positioning">positioning details</a> for more information.
		</td>
	</tr>
	<tr>
		<td class="code">position</td>
		<td><code>'center right'</code></td>
		<td>
			Specifies the position of the error message. See the <a href="#positioning">positioning details</a> for more information.
		</td>
	</tr>
	<tr>
		<td class="code">singleError</td>
		<td><code>false</code></td>
		<td>
			Enabling this shows only one validation error at a time.
		</td>
	</tr>
	<tr>
		<td class="code">speed</td>
		<td><code>'normal</code></td>
		<td>
			Error message's fade-in speed.
		</td>
	</tr>
</table>

<%--}}}--%>


<%--{{{ Error messages --%>


<a name="positioning"></a>
<h3>Error message positioning</h3>

<p>
	The error message position is specified with two different configuration properties: <samp>position</samp> and <samp>offset</samp>. The <samp>position</samp> property specifies the position in relation to the input field. For example, a value of <samp>'bottom center'</samp> will place the message on the bottom edge of the input, centered horizontally. The following image illustrates the "slots" that you can use:
</p>

<div style="background:url(../img/tooltip/positions.png) no-repeat -20px 0;height:340px"></div>

<p>
	The <samp>offset</samp> property fine tunes the tooltip position specified with the <samp>position</samp> property. For example, the value <samp>[10, -20]</samp> moves the tooltip position 10px downwards and 20px to the left. The first value modifies the vertical positioning from the top edge of the tooltip and the second value modifies the horizontal positioning from the left edge of the tooltip. Positive values move the tooltip downward and to the right, while negative values move the tooltip upward and to the left.
</p>




<a name="localization"></a>
<h3>Localization</h3>

<p>
	The default error messages are contained in the <samp>$.tools.validator.messages</samp> object. Here is a screenshot of all the messages contained inside the validator as seen from the <a href="http://getfirebug.com/" class="external">Firebug</a> console.
</p>

<p>
	<img src="img/messages.gif" alt="Validator default error messages" />
</p>

<p>
	The default error messages are in English. The <samp>*</samp> message is shown if there is no validator specific message available. If you want to provide error messages in other languages, use the <samp>$.tools.validator.localize</samp> method as follows:
</p>

<pii:code>
$.tools.validator.localize("fi", {
	':email'  		: 'Virheellinen s&auml;hk&ouml;postiosoite',
	':number' 		: 'Arvon on oltava numeerinen',
	'[max]'	 		: 'Arvon on oltava pienempi, kuin $1',
	'[min]'	 		: 'Arvon on oltava suurempi, kuin $1',
	'[required]' 	: 'Kent&auml;n arvo on annettava'
});
</pii:code>

<p>
	The first argument is the language code and the second argument is an object containing the localized messages. After calling the <samp>localize</samp> command you can check that everything went well with the Firebug console:
</p>

<p>
	<img src="img/messages-fi.gif" alt="Validator default error messages" />
</p>

<p>
The <samp>:email</samp> and <samp>:number</samp> localizations are opened. <strong style="color:#444;font-size:11px">more&hellip;</strong> indicates objects that can be opened to inspect localized messages. As you can see, this is not the case for <samp>*</samp> and <samp>:url</samp> which were not localized. The <samp>$1</samp> tokens in <samp>[max]</samp> and <samp>[min]</samp> are replaced with proper values once the message is shown to the user. You can take advantage of this <a href="#substitution">variable substitution</a> feature in your own custom validators.
</p>

<p>
	Now if you want to use the Finnish localization in your form you need to set the <a href="#configuration/lang">lang</a> configuration variable to "fi":
</p>

<pii:code>
$("#myForm").validator({lang: 'fi'});
</pii:code>

<h3>Localizing single validator</h3>

<p>
	Sometimes you just need to localize a single validator function. In that case you can use the <samp>$.tools.validator.localizeFn</samp> function. For example:
</p>

<pii:code>
$.tools.validator.localizeFn("[type=time]", {
	en: 'Please supply a valid time',
	fi: 'Virheellinen aika'
});
</pii:code>

<p>
	This will modify existing languages and/or add new ones for this single validator only. Note that with both localization functions you can generate the messages dynamically via JavaScript if you need to. Localization objects are plain old and dynamic JavaScript objects after all.
</p>


<a name="input_message"></a>
<h3>Input specific error message</h3>

<p>
	You can explicitly define the error message for a field that is shown when validation fails. It can be defined with the <samp>data-message</samp> attribute. For example:
</p>

<pii:code>
<input type="number" min="10" data-message="A larger value is needed" />
</pii:code>

<p>
	This will override any other error messages that are defined for the validation error. The drawback here is that you can only supply a single error message although there may be many different validation errors and that this error message cannot be localized. Of course you can supply a different value for this attribute on the server-side.
</p>

<p>
	Here is the order in which the error message is selected starting from the step 1 and if none of the steps result in any error message then the final option is shown.
</p>

<ol>
	<li>a value specified in the <samp>data-message</samp> attribute</li>
	<li>
		a validator specific error message that matches the language specified in the <samp>lang</samp> configuration option
	</li>
	<li>the default error message that is configured with the asterisk (<samp>*</samp>) in the <samp>$.tools.validator.messages</samp> object
</ol>

<p>
	As you might have noticed, the name of the <samp>data-message</samp> attribute features a somewhat cumbersome <samp>data-</samp> prefix. This actually makes the attribute valid HTML5, and your fields will successfully pass a <a href="http://html5.validator.nu/" class="external">HTML5 validator</a>. If you are one of those people who do not care about techy standards and want your forms to be more readable, you can change the name of this attribute from within the configuration using the <samp>messageAttr</samp> configuration variable.
</p>




<%--}}}--%>


<%--{{{ custom validators --%>

<a name="custom"></a>
<h2>Making custom validators</h2>

<p>
	jQuery Tools Validator makes it easy to create new input types and attributes. When building your forms you'll typically use the built-in HTML5 features and also add a couple of your own custom validators. Here is an example:
</p>

<pii:code>
// make a HTML5 "time" input type
$.tools.validator.fn("[type=time]", function(el, value) {
	return /\d\d:\d\d/.test(value) ? true : "Invalid time";
});
</pii:code>

<p>
	You can find more examples <a href="../demos/validator/custom-validators.html">here</a>. Here is the <samp>$.tools.validator.fn</samp> and its arguments explained:
</p>

<pii:code>
$.tools.validator.fn(matcher, [errorMessages], validator)
</pii:code>

<table class="listing">
	<thead>
		<tr>
			<th>Argument</th>
			<th>Type</th>
			<th>Description</th>
		</tr>
	</thead>

	<tr>
		<td class="code">matcher</td>
		<td><code>string or function</code></td>
		<td>
			A jQuery selector that matches an input to be validated. For example the selector <samp>[name=password]</samp> will match all inputs whose "name" attribute is "password", and <samp>:file</samp> will match all file inputs. All <a href="http://api.jquery.com/category/selectors/" class="external">jQuery selectors</a> can be used to filter out desired inputs. You can also use <a href="#function_matcher">function matchers</a>.
		</td>
	</tr>
	<tr>
		<td class="code">errorMessages</td>
		<td><code>string or object</code></td>
		<td>
			Optional error message associated with the validator. A string value defines a message in the default English language, and an object represents an error message in multiple languages, for example <samp>{en: 'English error message', fi: 'Finnish error message'}</samp>. You can also use <a href="#substition">variable substitution</a> in your error messages.
		</td>
	</tr>
	<tr>
		<td class="code">validator</td>
		<td><code>function</code></td>
		<td>
			This is the actual validator function that does the job. Inside the function the <samp>this</samp>-variable references the validator <a href="#api">API</a>. The function accepts two arguments: The first argument provides a jQuery object representing the element to be validated, and the second argument provides the invalid value. Four types of return values are supported

			<ol>
				<li>Returning <samp>true</samp> from your validator means that the value passes your validation logic.</li>
				<li>An <samp>Array</samp> represents values for <a href="#substitution">variable substitution</a>.</li>
				<li>A <samp>string</samp> value represents an error message in a specific language.</li>
				<li>An <samp>object</samp> represents a localized error message.</li>
			</ol>
		</td>
	</tr>

</table>


<p>
	As you can see you can supply error messages in two ways: as the second argument to the <samp>$.tools.validator.fn</samp> function as well as by returning them from the validator function. When supplying them as the second argument you can take advantage of the centralized <a href="#localization">language configuration</a> where the error messages can be changed and new languages can be added. When returning error messages from your validator you have much greater control of the dynamic construction of the error messages, but the messages are hard-coded inside your function.
</p>

<p>
	If your validator function provides error messages in <em>both</em> of the previous ways, the one that is returned by the validator function takes precedence.
</p>


<a name="substitution"></a>
<h3>Variable substitution</h3>

<p>
	This feature is best explained by way of an example:
</p>

<pii:code>
$.tools.validator.fn("[type=range]", "Value must be between $1 and $2", function(el, v) {

	// get min and max for this field from the (HTML5) attributes
	var min = el.attr("min"), max = el.attr("max"), value = parseFloat(v);

	// if the value is inside the range return true otherwise return values for replacement
	return  value >= min && value <= max ? true : [min, max];
});
</pii:code>

<p>
	The error message given in the second argument contains two <em>replacement tokens</em>, <samp>$1</samp> and <samp>$2</samp>, which will be expanded to the respective values of the two members in the Array returned by the validator function: <samp>[value1, value2]</samp>.
</p>

<a name="function_matcher"></a>
<h3>Function matcher</h3>

<p>
	Instead of a jQuery selector you can use a function to determine which fields are to be validated by your custom validator. For example:
</p>

<pii:code>
// 1st argument provides the function matcher
$.tools.validator.fn(function()  {

	// returning true means that a match was found
	return $(this).parents("form.register").length > 0;

// 2nd argument provides the actual validator function
}, function(el, v) {

	// do your validation. return true if the value is valid
	return true;

});
</pii:code>

<p>
	Our matcher only selects inputs that are within a <samp>form</samp> with class name "register". This is probably not a real world situation, but it does show you how it works. You have complete control over the selection.
</p>

<h4>Localization &amp; function matchers</h4>

<p>
	You can return the error message from the validator function directly. If you want to take advantage of the <samp>$.tools.validator.messages</samp> object in your localization, we need to have a key for your matcher. The key is given as a property of the validator function as follows:
</p>

<pii:code>
// define the function matcher
function myMatcher() {
   return $(this).parents("form.register").length > 0;
}

// supply a key for the matcher
myMatcher.key = "register-input";

// use the "localized" matcher on our validator
$.tools.validator.fn(myMatcher, "Please fix this value", function(el, v) {

   // do your validation. return true if the value is valid
   return true;
});
</pii:code>

<p>
	Now you can inspect the custom validator in the <samp>$.tools.validator.messages</samp> object (last line):
</p>

<p>
	<img src="img/messages-custom.gif" alt="Localization of the function matcher" />
</p>

<%--}}}--%>


<%--{{{ API --%>

<a name="api"></a>
<h2>Scripting API</h2>

<p>
	First make sure you have familiarized yourself with <a href="${jqt}/documentation/scripting.html">jQuery Tools scripting</a>.
</p>

<table class="listing">
	<thead>
		<tr>
			<th>Method</th>
			<th nowrap>Return value</th>
			<th>Description</th>
		</tr>
	</thead>

	<tr>
		<td class="code">checkValidity()</td>
		<td><code>boolean</code></td>
		<td>
			Performs the form validation routine.
		</td>
	</tr>
	<tr>
		<td class="code">destroy()</td>
		<td><code>API</code></td>
		<td>
			<strong>Since 1.2.3</strong> completely removes existing validator instance.
		</td>
	</tr>		
	<tr>
		<td class="code">getConf()</td>
		<td><code>Object</code></td>
		<td>
			Returns the configuration of the current validator instance.
		</td>
	</tr>
	<tr>
		<td class="code">getForm()</td>
		<td><code>jQuery</code></td>
		<td>
			Returns the form element associated with the validator. May be <samp>null</samp>.
		</td>
	</tr>
	<tr>
		<td class="code">getInputs()</td>
		<td><code>jQuery</code></td>
		<td>
			Returns all input fields associated with the validator.
		</td>
	</tr>
	<tr>
		<td class="code">invalidate(Object)</td>
		<td><code>API</code></td>
		<td>
			Invalidates the form with the error messages given in the argument. Causes the <samp>onFail</samp> event and input specific <samp>ininvalid</samp> events to be fired. This function is useful for <a href="#server_side">server-side integration</a>.
		</td>
	</tr>
	<tr>
		<td class="code">reflow()</td>
		<td><code>API</code></td>
		<td>
			<strong>since 1.2.4</strong> repositions error messages correctly. Since messages are positioned absolutely in relative to the document body the messages can be misplaced when the form is moved or it's contents is manipulated. Calling this method fixes the situation. Reflow happens automatically when the window is resized. Repositioning works like a snap and cannot be seen with human eye. 
		</td>
	</tr>	
	<tr>
		<td class="code">reset(jQuery)</td>
		<td><code>API</code></td>
		<td>
			<strong>since 1.2.2</strong> resets the input fields that given in argument. This is opposite to the invalidate method making the fields valid. If no fields are give then all inputs are made valid. If you have a reset button on your form this reset function is automatically bind to it.
		</td>
	</tr>	
</table>

<%--}}}--%>


<%--{{{ Events--%>

<a name="events"></a>
<h2>Events</h2>

<p>
	First make sure you have read about <a href="${jqt}/documentation/scripting.html#events">Events in jQuery Tools</a>. All event listeners receive an <a href="${jqt}/documentation/scripting.html#event_object">Event Object</a> as the first argument.
</p>

<p>
	You can view a demo here about <a href="${jqt}/demos/validator/events.html">validator events</a>.
</p>

<table class="listing">
	<thead>
		<tr>
			<th>Event</th>
			<th nowrap>When does it occur?</th>
		</tr>
	</thead>


	<tr>
		<td class="code">onBeforeFail</td>
		<td>
			Before a validation error occurs. The event is fired as many times as there are validation errors. Returning <samp>false</samp> causes a single error to be skipped. The second argument is the invalid input field, and the third argument is the matcher string associated with the validator function such as <samp>:email</samp>.
		</td>
	</tr>
	<tr>
		<td class="code">onBeforeValidate</td>
		<td>
			Before the validation routine starts. Returning <samp>false</samp> causes the validation to be skipped altogether. The second argument is a jQuery object containing all invalid input fields.
		</td>
	</tr>
	<tr>
		<td class="code">onFail</td>
		<td>
			After all errors are populated, but before they are displayed to the user. Returning <samp>false</samp> causes the underlying display effect to be skipped, and the error messages are not shown. The second argument is an array of <samp>Error</samp> objects. Each error object has two properties: <samp>input</samp>, which is the erroneous input, and <samp>messages</samp>, which is an array of error messages.
		</td>
	</tr>
	<tr>
		<td class="code">onSuccess</td>
		<td>
			After the validation, if one or more fields are valid. The second argument is a jQuery object containing all fields that passed the validation. 
		</td>
	</tr>

</table>

<h3>Field specific events</h3>

<p>
	If you want to listen to validation errors on a field level you have the <samp>oninvalid</samp> method available. For example
</p>

<pii:code>
$("[name=password]").oninvalid(function(event, errorMessage) {

	// get handle to the API
	var api = $(this).data("validator");
});
</pii:code>



<%--}}}--%>


<%--{{{ Server-side --%>

<a name="server_side"></a>
<h2>Server-side integration</h2>

<p>
	Here is the logic taken from the <a href="${jqt}/demos/validator/server-side.html">server-side validation</a> demo. Please read the comment blocks and see the natural and standards-based syntax.
</p>

<pii:code>
// initialize validator and add the custom form submission logic
$("#myform").validator({ position: 'center right' }).submit(function(e) {

	var form = $(this);

	// client-side validation passed
	if (!e.isDefaultPrevented()) {

		// submit the data to the server with AJAX
		$.getJSON(form.attr("action") + "?" + form.serialize(), function(json) {

			// everything is ok. (the server returned true)
			if (json === true)  {
				form.load("success.php");

			// server-side validation failed. use invalidate() to show errors
			} else {
				form.data("validator").invalidate(json);
			}
		});

		// prevent default form submission logic
		e.preventDefault();
	}
});
</pii:code>

<p>
	Here we used the simple return value <samp>true</samp> to indicate that the data was valid on the server-side. You can do whatever you wish when the data is good. Here we replaced the form contents with a server-side page. If the data was not valid we use the <samp>invalidate</samp> method to display errors to the user. The <samp>invalidate</samp> method accepts an object argument which maps a field name to an error message like this:
</p>

<pii:code>
{
 	"zip": "You must live in northern Finland in order to proceed",
	"total": "You gave us too much money! Please check"
}
</pii:code>

<p>
	You can switch the language of the errors on the server. <strong>Note:</strong> jQuery 1.4+ requires that both labels and values are quoted with double quotes on the returned JSON.
</p>

<%--}}}--%>

<a name="effects"></a>
<h2>Making custom effects</h2>

<p>
	The default validator effect is responsible for displaying the validation errors beside each input field and when the user fixes the problems the effect hides the associated error messages accordingly. If you want to alter this behaviour you can write your own custom validator effect. For example, you may want to show those errors in a single container instead of beside each input field.
</p>

<p>
	Custom effects are added with the <samp>$.tools.validator.addEffect</samp> method. This method accepts three arguments. The first argument is the effect name, the second argument is a function that is called when there are validation errors available and the third argument is a function that is called when an input field switches from an invalid to a valid state. Here is an example:
</p>

<pii:code>
// adds an effect called "wall" to the validator
$.tools.validator.addEffect("wall", function(errors, event) {

	// "show" function
	$.each(errors, function(index, error) {

		// erroneous input
		var input = error.input;

		// error messages for the input (Array)
		var errors = error.messages;
	});

}, function(inputs)  {
	// "hide" function

});
</pii:code>


<p>
	The show function receives two arguments. The first argument is an array of <samp>Error</samp> objects. Each error object has two properties: <samp>input</samp>, which is the erroneous input, and <samp>messages</samp> which is an array of error messages. The second argument is the event that fired the validation. This may be the form submission or a change in an input field.
</p>

<p>
	The hide function receives a jQuery object containing all input fields that are switching to a valid state after being invalid.
</p>

<p>
	Take a look at a simple <a href="${jqt}/demos/validator/custom-effect.html">custom validator effect</a> in action.
</p>
